# 组件库迁移指南

## 概述

本文档旨在指导开发团队如何逐步将项目中的 MUI 和 Ant Design 组件替换为我们自定义的组件库。迁移过程采用渐进式策略，确保系统稳定性并降低风险。

## 迁移背景与目标

- **现状**：项目目前存在 UI 框架混用问题（@mui/material、antd），增加了维护成本和潜在的样式冲突
- **目标**：
  - 统一使用自定义组件库，提高代码一致性
  - 减少第三方依赖，降低打包体积
  - 建立组件版本控制和更新机制
  - 提升整体设计语言的一致性

## 迁移策略

### 3.1 渐进式迁移

采用**渐进式迁移**策略，按以下优先级进行：

1. **非关键路径组件**：先从非核心业务流程的组件开始迁移
2. **高频使用组件**：优先迁移使用频率高的基础组件
3. **页面级迁移**：逐步按页面维度完成迁移
4. **核心业务组件**：最后迁移核心业务流程相关组件

### 3.2 迁移周期

| 阶段 | 时间 | 重点任务 |
|------|------|----------|
| 准备阶段 | 1周 | 组件库文档完善、开发环境配置 |
| 初始迁移 | 2周 | 迁移 Alert、Button、Input 等基础组件 |
| 批量迁移 | 4-6周 | 按页面/模块批量迁移组件 |
| 验证阶段 | 2周 | 全面测试和问题修复 |
| 收尾阶段 | 1周 | 移除旧依赖、代码优化 |

## 组件映射表

### 4.1 MUI 组件映射

| MUI 组件 | 自定义组件 | 替换指南 |
|---------|-----------|----------|
| Button | Button | 直接替换，props 基本兼容 |
| TextField | Input | 需调整 props 命名 |
| Select | Select | 需重新实现选项逻辑 |
| Alert | Alert | 使用新的 Alert、AlertTitle、AlertDescription |
| Dialog | Dialog | 需调整事件处理方式 |
| Card | Card | 结构类似，可直接替换 |

### 4.2 Ant Design 组件映射

| Ant Design 组件 | 自定义组件 | 替换指南 |
|---------------|-----------|----------|
| Button | Button | 直接替换，props 基本兼容 |
| Input | Input | 需调整 props 命名 |
| Select | Select | 需重新实现选项逻辑 |
| Progress | Progress | 使用我们的自定义进度条组件 |
| Tooltip | Tooltip | 使用我们的自定义提示组件 |
| Table | Table | 结构差异较大，需重构实现 |

## 迁移步骤

### 5.1 环境准备

1. 确保项目已安装最新版本的依赖：
   ```bash
   pnpm install
   ```

2. 引入自定义组件库：
   ```typescript
   // 从统一入口导入组件
   import { Button, Input, Alert } from '@/components/ui'
   ```

### 5.2 单个组件迁移示例

以替换 Ant Design 的 Button 组件为例：

#### 迁移前
```typescript
import { Button } from 'antd'
import { PlusOutlined } from '@ant-design/icons'

const Example = () => (
  <Button type="primary" icon={<PlusOutlined />} size="large">
    添加
  </Button>
)
```

#### 迁移后
```typescript
import { Button } from '@/components/ui'
import { Plus } from 'lucide-react'

const Example = () => (
  <Button variant="default" size="lg" className="bg-primary text-white">
    <Plus className="mr-2 h-4 w-4" />
    添加
  </Button>
)
```

### 5.3 页面级迁移流程

1. **分析页面依赖**：识别页面中使用的所有 MUI/Ant Design 组件
2. **创建迁移计划**：确定组件替换顺序和优先级
3. **实施替换**：逐个替换组件并调整 props
4. **本地测试**：验证功能和样式是否正常
5. **代码审查**：提交 PR 进行代码审查
6. **部署验证**：在测试环境验证迁移结果

## 版本控制与更新机制

### 6.1 组件版本管理

我们的组件库实现了完整的版本控制机制：

- 每个组件都注册了版本信息（版本号、更新日期、描述）
- 使用 `ComponentVersionManager` 进行统一管理
- 支持组件版本查询和兼容性检查

### 6.2 如何查看组件版本

```typescript
import { ComponentVersionManager } from '@/components/ui/versioning'

// 获取所有组件版本信息
const allVersions = ComponentVersionManager.getInstance().getAllVersions();
console.log('组件版本信息:', allVersions);

// 检查特定组件版本
const buttonVersion = ComponentVersionManager.getInstance().getComponentVersion('Button');
console.log('Button 组件版本:', buttonVersion);
```

### 6.3 处理组件更新

1. **更新通知**：组件库会在有新版本时显示通知
2. **更新日志**：通过运行以下命令生成更新日志：
   ```bash
   pnpm run generate-changelog
   ```
3. **兼容性检查**：使用版本管理器检查组件兼容性

## 最佳实践

### 7.1 组件使用建议

- **统一导入路径**：始终从 `@/components/ui` 统一入口导入组件
- **避免直接修改样式**：优先使用组件提供的 variant 和 className props
- **使用 TypeScript**：充分利用类型提示确保正确使用组件
- **遵循设计规范**：确保组件使用符合项目设计规范

### 7.2 性能优化

- **按需导入**：虽然提供了统一入口，但也支持按需导入减少包体积
- **避免不必要的重渲染**：合理使用 memo 和 useCallback
- **使用虚拟化**：处理大量数据时使用虚拟化组件

## 常见问题与解决方案

### 8.1 样式冲突

**问题**：替换组件后出现样式不一致

**解决方案**：

- 使用浏览器开发工具检查样式覆盖情况
- 添加自定义 className 调整样式
- 检查是否有全局样式影响组件

### 8.2 Props 不兼容

**问题**：旧组件的某些 props 在新组件中不存在

**解决方案**：

- 参考组件文档查找替代方案
- 使用适配器模式处理不兼容的 props
- 联系组件库维护团队寻求支持

### 8.3 功能缺失

**问题**：新组件缺少旧组件的某些功能

**解决方案**：

- 使用高阶组件扩展功能
- 提交功能需求给组件库团队
- 暂时保留部分旧组件直到功能完善

## 迁移检查清单

- [ ] 识别页面中所有需要迁移的组件
- [ ] 查阅组件映射表确定替换方案
- [ ] 进行组件替换和 props 调整
- [ ] 更新相关的类型定义
- [ ] 本地测试功能和样式
- [ ] 执行单元测试和集成测试
- [ ] 检查组件版本兼容性
- [ ] 提交代码审查并获取反馈
- [ ] 在测试环境验证迁移结果

## 支持与资源

### 10.1 文档资源

- [组件库使用指南](./组件库使用指南.md)
- [组件 API 文档](./components-api/)
- [版本更新日志](./changelog.md)

### 10.2 联系支持

- **组件库维护团队**：通过内部 Slack 频道 #component-library
- **技术问题反馈**：在项目 JIRA 中创建 "组件库" 标签的 issue
- **紧急支持**：联系前端架构师 on-call 人员

## 结语

组件库迁移是一个系统性工程，需要团队协作和持续努力。通过渐进式迁移策略，我们可以确保系统稳定性的同时，逐步实现组件库的统一，为项目的长期发展奠定坚实基础。

请所有团队成员严格遵循本指南进行迁移工作，如有任何问题或建议，请及时反馈给组件库维护团队。

---

*文档维护者：组件库团队*
*最后更新时间：2024-10-15*